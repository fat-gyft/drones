-- Copyright (c) 2015 FAT-GYFT, MIT License

procedure genWorlds (u : Universe)
var
  worlds : Sequence(World),
  aWorld : World,
  aWorld2 : World,

  nbCells : Integer,
  nbDronesOut : Integer,

  cells : Sequence(Cell),
  aCell : Cell,
  warehouseCell : Cell,

  receptacles : Sequence(Receptacle),
  warehouse : Warehouse,

  aDrone : Drone,
  drones : Sequence(Drone);

begin
  ---------------------
  -- Generating grid --
  ---------------------

  nbCells := [u.SIDE * u.SIDE];
  cells := CreateN(Cell, [nbCells]);

  for i:Integer in [Sequence{1..(nbCells)}]
  begin
    Insert(Cells, [u], [cells->at(i)]);

    -- Adding neighbors:
    --------------------
    --  [1 2 3
    --   4 5 6
    --   7 8 9]
    -- Like this but both ways:
    --  1: 2 4
    --  2: 3 5
    --  3: 6
    --  4: 5 7
    --  5: 6 8
    --  6: 9
    --  7: 8
    --  8: 9
    --  9: /

    if [i < nbCells] then
    begin
      -- i % u.SIDE <> 0
      if [i - u.SIDE * (i div u.SIDE) <> 0] then
      begin
        Insert(Neighbors, [cells->at(i)], [cells->at(i + 1)]);
        Insert(Neighbors, [cells->at(i + 1)], [cells->at(i)]);
      end;
      if [i + u.SIDE <= nbCells] then
      begin
        Insert(Neighbors, [cells->at(i)], [cells->at(i + u.SIDE)]);
        Insert(Neighbors, [cells->at(i + u.SIDE)], [cells->at(i)]);
      end;
    end;
  end;

  -----------------------
  -- Generating worlds --
  -----------------------

  worlds := CreateN(World, [u.TICN]);

  for i:Integer in [Sequence{1..u.TICN - 1}]
  begin
    Insert(NextWorld, [worlds->at(i)], [worlds->at(i + 1)]);
  end;

  ----------------------------------------
  -- Inserting into Worlds and Universe --
  ----------------------------------------

  warehouseCell := Any([cells]);

  for wi:Integer in [Sequence{1..u.TICN}]
  begin
    receptacles := CreateN(Receptacle, [u.RNB]);
    for r:Receptacle in [receptacles]
    begin
      [r].nbProducts := Any([Sequence{0..u.RCAP}]);
    end;

    warehouse := Create(Warehouse);
    Insert(HasWarehouse, [warehouseCell], [warehouse]);

    for i:Integer in [Sequence{1..u.RNB}]
    begin
      aCell := Try([cells]);
      Insert(HasReceptacle, [aCell], [receptacles->at(i)]);
    end;

    -----------------------
    -- Generating drones --
    -----------------------
    drones := CreateN(Drone, [u.DNB]);
    for i:Integer in [Sequence{1..u.DNB}]
    begin
      [drones->at(i)].id := [i];
      [drones->at(i)].nbProducts := [0];
      [drones->at(i)].remainingBattery := [u.MAXB];
    end;

    -- Adding a random number of them on the grid
    nbDronesOut := Any([Sequence{1..u.DNB}]);
    for i:Integer in [Sequence{1..nbDronesOut}]
    begin
      aDrone := Try([drones]);
      aCell := Any([cells]);
      Insert(Position, [aDrone], [aCell]);
    end;

    ---------------
    -- Insertion --
    ---------------

    Insert(Worlds, [u], [worlds->at(wi)]);

    Insert(WorldWarehouse, [worlds->at(wi)], [warehouse]);

    for i:Integer in [Sequence{1..u.RNB}]
    begin
      Insert(WorldReceptacles, [worlds->at(wi)], [receptacles->at(i)]);
    end;

    for i:Integer in [Sequence{1..u.DNB}]
    begin
      Insert(WorldDrones, [worlds->at(wi)], [drones->at(i)]);
    end;
  end;
end;


procedure TicTac (w: World)
begin
---------------   for d:Drone in [w.drones->asSequence()]
---------------   begin
---------------     [d].remainingBattery := [d.remainingBattery - 1];
---------------   end;
end;


