-- Copyright (c) 2015 FAT-GYFT, MIT License

-- procedure genWorld (u : Universe)
-- 
-- var
--   drones : Sequence(Drone), aDrone : Drone,
--   receptacles : Sequence(Receptacle), aReceptacle : Receptacle,
--   cells : Sequence(Cell), aCell : Cell, nbCells : Integer,
--   nbDronesOut : Integer,
--   warehouse : Warehouse,
--   nbReceptacles : Integer;
-- begin
--   -- Generating base grid
--   nbCells := [u.SIDE * u.SIDE];
--   cells := CreateN(Cell, [nbCells - u.RNB - 1]);
--   receptacles := CreateN(Receptacle, [u.RNB]);
--   warehouse := Create(Warehouse);
-- 
--   cells := [cells->append(warehouse)];
-- 
--   for i:Integer in [Sequence{1..u.RNB}]
--   begin
--     cells := [cells->append(receptacles->at(i))];
--   end;
-- 
--   -- Generating drones
--   drones := CreateN(Drone, [u.DNB]);
--   if [u.DNB < u.SIDE] then
--   begin
--     nbDronesOut := Any([Sequence{1..u.DNB}]);
--   end else begin
--     nbDronesOut := Any([Sequence{1..u.SIDE}]);
--   end;
-- 
--   for r:Receptacle in [receptacles]
--   begin
--     [r].nbProducts := Any([Sequence{0..u.RCAP}]);
--   end;
-- 
--   -- Adding neighbors
--   --  [1 2 3
--   --   4 5 6
--   --   7 8 9]
--   --
--   --  1: 2 4
--   --  2: 3 5
--   --  3: 6
--   --  4: 5 7
--   --  5: 6 8
--   --  6: 9
--   --  7: 8
--   --  8: 9
--   --  9: /
--   for i:Integer in [Sequence{1..(nbCells - 1)}]
--   begin
--     -- i % u.SIDE <> 0
--     if [i - u.SIDE * (i div u.SIDE) <> 0] then
--     begin
--       Insert(Neighbors, [cells->at(i)], [cells->at(i + 1)]);
--       Insert(Neighbors, [cells->at(i + 1)], [cells->at(i)]);
--     end;
--     if [i + u.SIDE <= nbCells] then
--     begin
--       Insert(Neighbors, [cells->at(i)], [cells->at(i + u.SIDE)]);
--       Insert(Neighbors, [cells->at(i + u.SIDE)], [cells->at(i)]);
--     end;
--   end;
-- 
--   -- Adding a random number of them on the grid
--   for i:Integer in [Sequence{1..nbDronesOut}]
--   begin
--     aDrone := Try([drones]);
--    [aDrone].nbProducts := [u.DCAP];
--    [aDrone].remainingBattery := [u.MAXB];
--     aCell := Any([cells]);
--     Insert(Position, [aDrone], [aCell]);
--   end;
-- end;

procedure genWorlds (u : Universe)
var
  worlds : Sequence(World),
  aWorld : World,
  aWorld2 : World,

  nbCells : Integer,

  cells : Sequence(Cell),
  aCell : Cell,
  receptacles : Sequence(Receptacle),
  warehouse : Warehouse,
  drones : Sequence(Drone);

begin
  -----------------------
  -- Generating worlds --
  -----------------------

  worlds := CreateN(World, [u.TICN]);
  aWorld := Try([worlds]);
  aWorld2 := Try([worlds]);
  Insert(NextWorld, [aWorld], [aWorld2]);

  ----------------------------------------
  -- Inserting into Worlds and Universe --
  ----------------------------------------

  for wi:Integer in [Sequence{1..u.TICN}]
  begin
    ---------------------
    -- Generating grid --
    ---------------------

    nbCells := [u.SIDE * u.SIDE];
    cells := CreateN(Cell, [nbCells]);

    receptacles := CreateN(Receptacle, [u.RNB]);
    for r:Receptacle in [receptacles]
    begin
      [r].nbProducts := Any([Sequence{0..w.RCAP}]);
    end;

    warehouse := Create(Warehouse);

    aCell := Try([cells]);
    Insert(HasWarehouse, [aCell], [warehouse]);

    for i:Integer in [Sequence{1..u.RNB}]
    begin
      aCell := Try([cells]);
      Insert(HasReceptacle, [aCell], [receptacles->at(i)]);
    end;

    -- Adding neighbors:
    --------------------
    --  [1 2 3
    --   4 5 6
    --   7 8 9]
    -- Like this but both ways:
    --  1: 2 4
    --  2: 3 5
    --  3: 6
    --  4: 5 7
    --  5: 6 8
    --  6: 9
    --  7: 8
    --  8: 9
    --  9: /

    for i:Integer in [Sequence{1..(nbCells - 1)}]
    begin
      -- i % u.SIDE <> 0
      if [i - u.SIDE * (i div u.SIDE) <> 0] then
      begin
        Insert(Neighbors, [cells->at(i)], [cells->at(i + 1)]);
        Insert(Neighbors, [cells->at(i + 1)], [cells->at(i)]);
      end;
      if [i + u.SIDE <= nbCells] then
      begin
        Insert(Neighbors, [cells->at(i)], [cells->at(i + u.SIDE)]);
        Insert(Neighbors, [cells->at(i + u.SIDE)], [cells->at(i)]);
      end;
    end;

    -----------------------
    -- Generating drones --
    -----------------------
    drones := CreateN(Drone, [u.DNB]);

    ---------------
    -- Insertion --
    ---------------

    Insert(Worlds, [u], [worlds->at(wi)]);

    for i:Integer in [Sequence{1..nbCells}]
    begin
      Insert(WorldCells, [worlds->at(wi)], [cells->at(i)]);
    end;

    for i:Integer in [Sequence{1..u.DNB}]
    begin
      Insert(WorldDrones, [worlds->at(wi)], [drones->at(i)]);
    end;
  end;
end;


procedure TicTac (w: World)
var
  drones : Sequence(Drone),
  cells : Sequence(Cell),
  time : Time;
begin
  time := [w.head];
  drones := [time.allDrones->asSequence()];
  cells :=[time.allCells->asSequence()];
  
  for d:Drone in [drones]
  begin
    [d].remainingBattery := [d.remainingBattery - 1];
  end;
end;


