-- Copyright (c) 2015 FAT-GYFT, MIT License

procedure genWorld (w : World)

var
  drones : Sequence(Drone), aDrone : Drone,
  receptacles : Sequence(Receptacle), aReceptacle : Receptacle,
  cells : Sequence(Cell), aCell : Cell, nbCells : Integer,
  nbDronesOut : Integer,
  nbReceptacles : Integer;
begin
  -- Generating Grid
  nbCells := [w.SIDE * w.SIDE];
  cells := CreateN(Cell, [nbCells]);

--  [1 2 3
--   4 5 6
--   7 8 9]
--
--  1: 2 4
--  2: 3 5
--  3: 6
--  4: 5 7
--  5: 6 8
--  6: 9
--  7: 8
--  8: 9
--  9: /

  for i:Integer in [Sequence{1..(nbCells - 1)}]
  begin
    -- i % w.SIDE <> 0 and i + w.SIDE < nbCells
    if [i - w.SIDE * (i div w.SIDE) <> 0] then
    begin
      Insert(Neighbors, [cells->at(i)], [cells->at(i + 1)]);
    end;
    if [i + w.SIDE <= nbCells] then
    begin
      Insert(Neighbors, [cells->at(i)], [cells->at(i + w.SIDE)]);
    end;
  end;

  -- Generating drones
  drones := CreateN(Drone, [w.DNB]);
  if [w.DNB < w.SIDE] then
  begin
    nbDronesOut := Any([Sequence{1..w.DNB}]);
  end else begin
    nbDronesOut := Any([Sequence{1..w.SIDE}]);
  end;

  -- Generating receptacles
  for i:Integer in [Sequence{1..w.RNB}]
  begin
    --Create(Receptacle);
  end;

  -- Adding a random number of them on the grid
  for i:Integer in [Sequence{1..nbDronesOut}]
  begin
    aDrone := Try([drones]);
	--[aDrone->init];
    aCell := Any([cells]);
    Insert(Position, [aDrone], [aCell]);
  end;
end;