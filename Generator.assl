-- Copyright (c) 2015 FAT-GYFT, MIT License

procedure genWorld (c : Const)

var
  drones : Sequence(Drone), aDrone : Drone,
  receptacles : Sequence(Receptacle), aReceptacle : Receptacle,
  cells : Sequence(Cell), aCell : Cell, nbCells : Integer,
  nbDronesOut : Integer,
  nbReceptacles : Integer;

begin
  -- Generating Grid
  nbCells := [c.SIDE * c.SIDE];
  cells := CreateN(Cell, [nbCells]);

--  [1 2 3
--   4 5 6
--   7 8 9]
--
--  1: 2 4
--  2: 3 5
--  3: 6
--  4: 5 7
--  5: 6 8
--  6: 9
--  7: 8
--  8: 9
--  9: /

  for i:Integer in [Sequence{1..(nbCells - 1)}]
  begin
    -- i % c.SIDE <> 0 and i + c.SIDE < nbCells
    if [i - c.SIDE * (i div c.SIDE) <> 0] then
    begin
      Insert(Neighbors, [cells->at(i)], [cells->at(i + 1)]);
    end;
    if [i + c.SIDE <= nbCells] then
    begin
      Insert(Neighbors, [cells->at(i)], [cells->at(i + c.SIDE)]);
    end;
  end;

  -- Generating drones
  drones := CreateN(Drone, [c.DNB]);
  nbDronesOut := Any([Sequence{1..c.DNB}]);
  
   -- Generating receptacles
  receptacles := CreateN(Receptacle, [c.RNB]);
  nbReceptacles := Any([Sequence{1..c.RNB}]);

  for r:Receptacle in [receptacles]
  begin
	[r].nbProducts := [c.RCAP];
  end;
  
  -- Adding a random number of them on the grid
  for i:Integer in [Sequence{1..nbDronesOut}]
  begin
    aDrone := Try([drones]);
	[aDrone].nbProducts := [c.DCAP];
    aCell := Any([cells]);
    Insert(Position, [aDrone], [aCell]);
  end;
end;