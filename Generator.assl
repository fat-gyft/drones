-- Copyright (c) 2015 FAT-GYFT, MIT License

procedure genWorlds (u : Universe)
var
  worlds : Sequence(World),
  aWorld : World,   --at t
  aWorld2 : World,  --at t-1

  nbCells : Integer,
  nbDronesMoving : Integer,

  sCell : Sequence(Cell),
  cells : Sequence(Cell),
  aCell : Cell,
  warehouseCell : Cell,
  baseCell : Cell,

  receptacles : Sequence(Receptacle),
  aReceptacle : Receptacle,
  warehouse : Warehouse,

  aDrone : Drone,
  bDrone : Drone,
  drones : Sequence(Drone);

begin
  ---------------------
  -- Generating grid --
  ---------------------

  nbCells := [u.SIDE * u.SIDE];
  cells := CreateN(Cell, [nbCells]);

  for i:Integer in [Sequence{1..(nbCells)}]
  begin
    Insert(Cells, [u], [cells->at(i)]);

    -- Adding neighbors:
    --------------------
    --  [1 2 3
    --   4 5 6
    --   7 8 9]
    -- Like this but both ways:
    --  1: 2 4
    --  2: 3 5
    --  3: 6
    --  4: 5 7
    --  5: 6 8
    --  6: 9
    --  7: 8
    --  8: 9
    --  9: /

    if [i < nbCells] then
    begin
      -- i % u.SIDE <> 0
      if [i - u.SIDE * (i div u.SIDE) <> 0] then
      begin
        Insert(Neighbors, [cells->at(i)], [cells->at(i + 1)]);
        Insert(Neighbors, [cells->at(i + 1)], [cells->at(i)]);
      end;
      if [i + u.SIDE <= nbCells] then
      begin
        Insert(Neighbors, [cells->at(i)], [cells->at(i + u.SIDE)]);
        Insert(Neighbors, [cells->at(i + u.SIDE)], [cells->at(i)]);
      end;
    end;
  end;

  -----------------------
  -- Generating worlds --
  -----------------------

  worlds := CreateN(World, [u.TICN]);

  for i:Integer in [Sequence{1..u.TICN - 1}]
  begin
    Insert(NextWorld, [worlds->at(i)], [worlds->at(i + 1)]);
  end;

  ----------------------------------------
  -- Inserting into Worlds and Universe --
  ----------------------------------------

  warehouseCell := Any([cells]);
  
  for wi:Integer in [Sequence{1..u.TICN}]
  begin
    receptacles := CreateN(Receptacle, [u.RNB]);
    for r:Receptacle in [receptacles]
    begin
      [r].nbProducts := Any([Sequence{0..u.RCAP}]);
    end;
    
    warehouse := Create(Warehouse);
    Insert(HasWarehouse, [warehouseCell], [warehouse]);

    for i:Integer in [Sequence{1..u.RNB}]
    begin
      aCell := Try([cells]);
      Insert(HasReceptacle, [aCell], [receptacles->at(i)]);
    end;

    -----------------------
    -- Generating drones --
    -----------------------
    drones := CreateN(Drone, [u.DNB]);
    for i:Integer in [Sequence{1..u.DNB}]
    begin
      [drones->at(i)].id := [i];
      [drones->at(i)].nbProducts := [0];
      [drones->at(i)].remainingBattery := [u.MAXB];
    end;

    if [wi > 1] then
    begin
      -- Adding a random number of them on the grid
      nbDronesMoving := Any([Sequence{1..u.DNB}]);
      for i:Integer in [Sequence{1..nbDronesMoving}]
      begin
      
        aWorld2 := [worlds->at(wi-1)];
     
        bDrone := [aWorld2.drones->asSequence()->at(i)];
        
        aDrone := [drones->at(i)];
        [aDrone].id := [aDrone.id];
        [aDrone].nbProducts := [aDrone.nbProducts];
        [aDrone].remainingBattery := [aDrone.remainingBattery];
        aReceptacle := Any([receptacles]);
        
        if[aDrone.position.isDefined() and aDrone.deliveringReceptacle.isDefined()
          and aDrone.position=aDrone.deliveringReceptacle.position] then
        begin
        
          Insert(Charges, [aDrone], [aDrone.deliveringReceptacle]);
          
        end else begin

          if [aDrone.position.neighbors->isDefined()] then
          begin
            baseCell := [aDrone.position];
          end else begin
             baseCell := [warehouseCell];
          end;

          aCell := [baseCell];
            for c:Cell in [baseCell.neighbors->asSequence()]
            begin
              if [c.drone.isUndefined()] then
              begin
                aCell := [c];
                [aDrone].nbProducts :=Any([Sequence{1..u.DCAP}]);
                if [aDrone.deliveringReceptacle.isUndefined()] then
                begin
                  Insert(ReceptaclePosition, [aDrone], [aReceptacle]);
                end;
              end;
            end;
            if [aDrone.position <> aCell] then
            begin
              [aDrone].remainingBattery :=[aDrone.remainingBattery-1];
            end;
            Insert(Position, [aDrone], [aCell]);
          end;  
      end;
    end;  -- end if wi > 1

    ---------------
    -- Insertion --
    ---------------
    
    Insert(Worlds, [u], [worlds->at(wi)]);

    Insert(WorldWarehouse, [worlds->at(wi)], [warehouse]);

    for i:Integer in [Sequence{1..u.RNB}]
    begin
      Insert(WorldReceptacles, [worlds->at(wi)], [receptacles->at(i)]);
    end;

    for i:Integer in [Sequence{1..u.DNB}]
    begin
      Insert(WorldDrones, [worlds->at(wi)], [drones->at(i)]);
    end;
  end;  -- end for all worlds
end;  -- end procedure


